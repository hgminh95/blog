<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>Which Loop Is Faster? | hgminh</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="The first loop access the memory sequentially from the beginning to the end of the array. The second one skip N steps between 2 iterations. Which one is faster?">
<meta name="generator" content="Hugo 0.68.3" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />




  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	
		<a href="https://github.com/hgminh95/blog">Github</a>
	

	
	  <a class="button" href="https://hgminh.dev/index.xml">Subscribe</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">Which Loop Is Faster?</h1>

    <div class="tip">
        <time datetime="2022-03-23 20:54:08 &#43;0800 &#43;08">Mar 23, 2022</time>
        <span class="split">
          ·
        </span>
        <span>
          wordCount
        </span>
        <span class="split">
          ·
        </span>
        <span>
          4 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#page-fault">Page fault</a></li>
    <li><a href="#tlb-misses">TLB misses</a></li>
    <li><a href="#cpu-cache">CPU Cache</a></li>
    <li><a href="#cache-prefetching">Cache Prefetching</a></li>
    <li><a href="#compiler-optimization">Compiler Optimization</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p>The first loop access the memory sequentially from the beginning to the end of the array. The second one skip N steps between 2 iterations. <strong>Which one is faster?</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> a[N <span style="color:#f92672">*</span> N];

<span style="color:#75715e">// Loop #1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>j)
    sum <span style="color:#f92672">+=</span> a[i <span style="color:#f92672">*</span> N <span style="color:#f92672">+</span> j];

<span style="color:#75715e">// Loop #2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>i)
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> N; <span style="color:#f92672">++</span>j)
    sum <span style="color:#f92672">+=</span> a[j <span style="color:#f92672">*</span> N <span style="color:#f92672">+</span> i];
</code></pre></div><p>I have run it and here is the result (you can find the code at <a href="https://github.com/hgminh95/which_loop_is_faster" target="_blank" rel="noopener">Github</a> - it is not exactly the same but should be close enough for this discussion)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">---------------------------------------------------------------------
Benchmark                           Time             CPU   Iterations
---------------------------------------------------------------------
BM_LoopNo1/16                     <span style="color:#ae81ff">131</span> ns          <span style="color:#ae81ff">108</span> ns      <span style="color:#ae81ff">8960000</span>
BM_LoopNo1/64                    <span style="color:#ae81ff">1965</span> ns         <span style="color:#ae81ff">1726</span> ns       <span style="color:#ae81ff">407273</span>
BM_LoopNo1/512                 <span style="color:#ae81ff">129987</span> ns        <span style="color:#ae81ff">97656</span> ns         <span style="color:#ae81ff">5600</span>
BM_LoopNo1/4096               <span style="color:#ae81ff">9786057</span> ns      <span style="color:#ae81ff">8789062</span> ns          <span style="color:#ae81ff">112</span>
BM_LoopNo1/8192              <span style="color:#ae81ff">39223035</span> ns     <span style="color:#ae81ff">21354167</span> ns           <span style="color:#ae81ff">30</span>
BM_LoopNo2/16                     <span style="color:#ae81ff">128</span> ns         73.4 ns     <span style="color:#ae81ff">10000000</span>
BM_LoopNo2/64                    <span style="color:#ae81ff">1975</span> ns         <span style="color:#ae81ff">1420</span> ns       <span style="color:#ae81ff">407273</span>
BM_LoopNo2/512                 <span style="color:#ae81ff">784854</span> ns       <span style="color:#ae81ff">619071</span> ns         <span style="color:#ae81ff">1792</span>
BM_LoopNo2/4096             <span style="color:#ae81ff">139502128</span> ns    <span style="color:#ae81ff">111111111</span> ns            <span style="color:#ae81ff">9</span>
BM_LoopNo2/8192             <span style="color:#ae81ff">794375658</span> ns    <span style="color:#ae81ff">656250000</span> ns            <span style="color:#ae81ff">1</span>
</code></pre></div><p>You can clearly see that loop #1 is faster. Now, let&rsquo;s find out why that is the case.</p>
<h2 id="page-fault">Page fault</h2>
<p><a href="https://en.wikipedia.org/wiki/Page_fault" target="_blank" rel="noopener">Page fault</a> happens when we try to access memory that is not in the main memory. The kernel need to delay the program and load the memory from storage like hard drive, which is very expensive. Since loop #2 jumps back and forth between different pages, it could trigger more page fault than #1 if N is big enough.</p>
<p>To check on the number of page faults, you can use below command</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ perf stat -e page-faults,minor-faults,major-faults &lt;program&gt;
</code></pre></div><p>Where <code>minor-faults</code> is when the page is in memory but is not registed to the memory management unit, <code>major-faults</code> is when the page is not in main memory, and <code>page-faults</code> is sum of them. Below is one possible result,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#e6db74">&#39;./bazel-bin/bm_loop --benchmark_filter=BM_LoopNo1WithPageFault&#39;</span>:

           785,074      page-faults
            33,743      major-faults
           751,331      minor-faults

<span style="color:#e6db74">&#39;./bazel-bin/bm_loop --benchmark_filter=BM_LoopNo2WithPageFault&#39;</span>:

           579,736      page-faults
           157,724      major-faults
           422,012      minor-faults
</code></pre></div><h2 id="tlb-misses">TLB misses</h2>
<p>The address refered by the application is virtual address. To access the memory, we actually need to translate them into physical address, by walking through the <a href="https://en.wikipedia.org/wiki/Page_tabl" target="_blank" rel="noopener">page table</a> (depsite the name, it is actually like a tree, hence &ldquo;walking&rdquo;). Since page table can be very large (say we have 16GB of RAM, which each page is 4KB, you do the math), we have something called <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="noopener">Translation Lookaside Buffer or TLB</a> to cache the page table. TLB miss happen when we try to access a page which is not in TLB.</p>
<p>Again, going back and forth between different pages won&rsquo;t help in this case either.</p>
<p>To see number of TLB misses, you can run below commands:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ perf stat -e dTLB-loads,dTLB-load-misses &lt;program&gt;
</code></pre></div><p>where <code>dTLB</code> is data TLB (there is <code>iTLB</code> for instruction), and <code>load-misses</code> means number of lookup that miss TLB.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#e6db74">&#39;./bazel-bin/bm_loop --benchmark_filter=BM_LoopNo1/8192&#39;</span>:

         2,494,435      dTLB-load-misses          <span style="color:#75715e">#    0.06% of all dTLB cache hits</span> 
     4,338,977,389      dTLB-loads

<span style="color:#e6db74">&#39;./bazel-bin/bm_loop --benchmark_filter=BM_LoopNo2/8192&#39;</span>:

        49,024,649      dTLB-load-misses          <span style="color:#75715e">#   25.15% of all dTLB cache hits</span> 
       194,919,514      dTLB-loads
</code></pre></div><h2 id="cpu-cache">CPU Cache</h2>
<p>Fetching memory from RAM is actually very slow, it could cost hundreds of clock cycles. That&rsquo;s why we have <a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">CPU cache</a>, which will store the memory inside the CPU, making subsequence accesses faster. There multiple levels of CPU cache (e.g. L1, L2, L3), with increasing latency and capacity.</p>
<p>But since we only access each element once in this example, how can cache help? Turn out we don&rsquo;t load 1 element to the cache at one time, we load a cache line, which usually are 64 bytes. So everytime we access an element, it will load 15 other elements (assuming int is 32-bit) to the cache, speeding up the next 15 memory access if we iterate them in sequential order.</p>
<p>You can check the cache miss number with below commands:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ perf stat -e LLC-load-misses,LLC-loads,cache-misses,cache-references,L1-dcache-load-misses,L1-dcache-loads &lt;program&gt;
</code></pre></div><p>where <code>LLC</code> is last level cache, <code>L1-dcache</code> is L1 data cache. <code>cache-misses</code> and <code>cache-references</code> are a bit complicated, which will be explained in the next section.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#e6db74">&#39;./bazel-bin/bm_loop --benchmark_filter=BM_LoopNo1/8192&#39;</span>:

         2,352,992      LLC-load-misses           <span style="color:#75715e">#   77.87% of all LL-cache hits</span>
         3,021,610      LLC-loads
       202,095,479      cache-misses              <span style="color:#75715e">#   68.146 % of all cache refs</span>  
       296,563,720      cache-references
       146,312,615      L1-dcache-load-misses     <span style="color:#75715e">#    3.36% of all L1-dcache hits</span>
     4,360,007,818      L1-dcache-loads


<span style="color:#e6db74">&#39;./bazel-bin/bm_loop --benchmark_filter=BM_LoopNo2/8192&#39;</span>:

        64,697,884      LLC-load-misses           <span style="color:#75715e">#   63.72% of all LL-cache hits</span>
       101,542,342      LLC-loads
        92,728,013      cache-misses              <span style="color:#75715e">#   29.577 % of all cache refs</span>  
       313,512,368      cache-references
       195,821,883      L1-dcache-load-misses     <span style="color:#75715e">#   98.11% of all L1-dcache hits</span>
       199,602,098      L1-dcache-loads
</code></pre></div><h2 id="cache-prefetching">Cache Prefetching</h2>
<p>You might realize something is off by looking at above number. How can number of cache misses are so small compared to 1:15 ratio? Again, CPU is one step ahead of us. It has something called prefetcher which will try to find out the memory access pattern to predict the next memory access, fetching them into the cache before we even access them.</p>
<h2 id="compiler-optimization">Compiler Optimization</h2>
<p>Processing the data sequentially also makes the compiler&rsquo;s job easier.</p>
<ul>
<li>GCC: <a href="https://godbolt.org/z/GWq55rsTr">https://godbolt.org/z/GWq55rsTr</a></li>
<li>Clang: <a href="https://godbolt.org/z/4Tcsodf8s">https://godbolt.org/z/4Tcsodf8s</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><a href="https://docs.kernel.org/vm/index.html" target="_blank" rel="noopener">Linux Virtual Memory</a></li>
<li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf" target="_blank" rel="noopener">Intel Software Developer&rsquo;s Manual Volume 3</a></li>
</ul>
    </div>

    
        <div class="tags">
            
                <a href="https://hgminh.dev/tags/performance">performance</a>
            
                <a href="https://hgminh.dev/tags/os">os</a>
            
                <a href="https://hgminh.dev/tags/memory">memory</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       hgminh
    
    </div>

    
</footer>



  </body>
</html>
